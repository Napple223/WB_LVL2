package pattern

import (
	"errors"
	"fmt"
)

/*
Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы,
а также реальные примеры использования данного примера на практике.
https://en.wikipedia.org/wiki/Factory_method_pattern

Фабричный метод — это порождающий паттерн проектирования,
который определяет общий интерфейс для создания объектов
в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

Применяемость:
1. Когда заранее неизвестны типы и зависимости объектов,
с которыми должен работать ваш код.
2. Когда вы хотите дать возможность пользователям
расширять части вашего фреймворка или библиотеки.
3. Когда вы хотите экономить системные ресурсы,
повторно используя уже созданные объекты, вместо порождения новых.

Преимущества:
1. Избавляет класс от привязки к конкретным классам продуктов.
2. Выделяет код производства продуктов в одно место, упрощая поддержку кода.
3. Упрощает добавление новых продуктов в программу.
4. Реализует принцип открытости/закрытости.

Недостатки:
1. Может привести к созданию больших параллельных иерархий классов,
так как для каждого класса продукта надо создать свой подкласс создателя.

В Go невозможно реализовать классический вариант паттерна Фабричный метод,
поскольу в языке отсутствуют классические возможности ООП (классы и наследственность).
Несмотря на это, мы все же можем реализовать базовую версию этого паттерна — Простая фабрика.
*/

//Мой пример:
//Необходима возможность создавать разные типы кроватей (односпальные металлические
//и двуспальные деревянные) в зависимости от входных данных.

// Интерфейс, определяющий методы кроватей.
type IBed interface {
	setSize(size int)
	setMaterial(material string)
	getSize() int
	getMaterial() string
}

// Структрура кровати.
type Bed struct {
	size     int
	material string
}

// Методы, имплементирующие интерфейс.
func (b *Bed) setSize(size int) {
	b.size = size
}

func (b *Bed) setMaterial(material string) {
	b.material = material
}

func (b *Bed) getSize() int {
	return b.size
}

func (b *Bed) getMaterial() string {
	return b.material
}

// Конкретная реализация кровати,
// в которую встроен родительский тип кровати.
type singleBed struct {
	Bed
}

// Метод - конструктор, запускающий сборку конкретной
// реализации кровати.
func NewSingleBed() IBed {
	return &singleBed{
		Bed: Bed{
			size:     1,
			material: "metal",
		},
	}
}

// Конкретная реализация кровати,
// в которую встроен родительский тип кровати.
type doubleBed struct {
	Bed
}

// Метод - конструктор, запускающий сборку конкретной
// реализации кровати.
func NewDoubleBed() IBed {
	return &doubleBed{
		Bed: Bed{
			size:     2,
			material: "wood",
		},
	}
}

// Функция для инициализации сборки необходимой
// реализации объекта, в зависимости от
// входных данных.
func getBed(bedType string) (IBed, error) {
	if bedType == "single" {
		return NewSingleBed(), nil
	}
	if bedType == "double" {
		return NewDoubleBed(), nil
	}
	return nil, errors.New("wrong bed type")
}

func testSimpleFactory() {
	singleBed, _ := getBed("single")
	fmt.Println(singleBed.getSize())     //1
	fmt.Println(singleBed.getMaterial()) //metal
	doubleBed, _ := getBed("double")
	fmt.Println(doubleBed.getSize())     //2
	fmt.Println(doubleBed.getMaterial()) //wood
}
